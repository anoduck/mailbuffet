#!/usr/bin/env python
# coding: utf-8

# # Mail Buffet
#
# > Extracting Mbox messages to markdown files

# ### Perform imports

# In[2]:


#!/usr/bin/env python3
#! vim:set filetype=python
# -*- coding: utf-8 -*-
# -*- mode: python -*-
# MIT License = 'Copyright (c) 2024 Anoduck'
# This software is released under the MIT License.
# https://anoduck.mit-license.org

# ----------------------------------------------
# This script was inspired by and parts of the code was borrowed from
# an effort to understand how to use the python program formbox written
# by Nguyá»n Gia Phong.
# ---------------------------------------------

import simple_parsing
from dataclasses import dataclass
from operator import itemgetter, contains
from mailbox import mbox
from email.header import decode_header
from email.utils import parsedate_to_datetime
from urllib.parse import urlencode
from py_markdown_table.markdown_table import markdown_table
import os


# ### Process Args
#
# It appears the ipykernel does not like simple_parsing, which is weird.
#
# Hardcoding args to circumvent.

# In[3]:

@dataclass
class Options:
    """
    A more than simple script to parse the mbox file generated by Google Takeout
    into individual text files with markdown syntax.

    Script also performs redacting based on keyphrase file, a text file containing one
    keyphrase per line saved as a txt file.

    Will generate index file containing markdown_table to provide TOC to files from webpath.

    """
    mbox: str = './exported.mbox'  # Mbox file for extraction
    outdir: str = './results'  # Directory to write files to
    priv: str = './sensitive.txt'  # File containing sensitive key phrases.
    webpath: str = '/Documents/emails'  # Relative Webpath from site root


Options = simple_parsing.parse(Options)


# ### Return Mbox object with initializer

# In[4]:


def get_mbox(mbox_file):
    return mbox(mbox_file, create=False)


def write_table(table, filepath):
    mdtbl = markdown_table(table).set_params(row_sep='markdown', quote=False).get_markdown()
    with open(filepath, 'w', encoding='utf-8') as wt:
        wt.write('## Email Table of Contents')
        wt.write('\n')
        wt.write(mdtbl)
        wt.write('\n')
        wt.write('----')
        wt.write('\n')
        wt.write('Generated by mailbuffet | [Mailbuffet](https://github.com/anoduck/mailbuffet)')
        wt.close()
    print('Index written to file.')

# ### Generate Index


def generate_index(msg_list, outdir, webpath):
    filename = 'email-index.txt'
    filepath = os.path.join(outdir, filename)
    table = []
    for thread in msg_list:
        if thread.get('has_children'):
            parent_message = thread.get('parent')
            unsorted_children = thread.get('children')
            children = sorted(unsorted_children, key=itemgetter('date'), reverse=True)
            child_ids = [i for i['Message-Id'] in children]
            fname = get_name(parent_message)
            fpath = webpath + '/' + filename
            flink = str(f'[{fname}]({fpath})')
            parent_subject = parent.get('Subject')
            parent_date = get_date(parent)
            tbl_row = {"Subject": parent_subject,
                       "Date": parent_date,
                       "Path": flink,
                       "Replies": child_ids}
            table.append(tbl_row)
        else:
            omsg = thread.get('parent')
            oname = get_name(omsg)
            opath = webpath + '/' + oname
            olink = str(f'[{oname}]({opath})')
            osubj = omsg.get('Subject')
            odate = get_date(omsg)
            tbl_row = {"Subject": osubj,
                       "Date": odate,
                       "Path": olink,
                       "Replies": "N/A"}
            table.append(tbl_row)
    write_table(table, filepath)


# ### Get Message parts

# #### Reply to params (???)

# In[40]:


def reply_to(message):
    """Return mailto parameters for replying to the given email."""
    yield 'In-Reply-To', message['Message-ID']
    yield 'Cc', message.get('Reply-To', message['From'])
    subject = message['Subject']
    if subject is None: return
    if subject.lower().startswith('re:'):
        yield 'Subject', subject
    else:
        yield 'Subject', f'Re: {subject}'


# #### Get Header

# In[41]:


def get_header(msg):
    """Return the decoded email header."""
    header = msg.get('header')
    ret_str = str('### Header: ')
    for string, charset in decode_header(header):
        encoding = 'utf-8' if charset is None else charset
        decoded = string.decode(encoding)
        ret_str += decoded + '\n'
    return ret_str


# #### Get Date

# In[6]:


def get_date(message):
    return parsedate_to_datetime(message['Date']).date()


# #### Get Body

# In[43]:


def get_body(message):
    if message.is_multipart():
        for payload in map(get_body, message.get_payload()):
            if payload is not None: return payload
    elif message.get_content_type() in ('text/markdown', 'text/plain'):
        payload = message.get_payload(decode=True).decode()
        return payload
    else:
        return None


def get_author(message):
    msgfrom = message['From']
    string = [s for s, _ in decode_header(msgfrom)]
    author = ''.join(string).rsplit(maxsplit=1)[0]
    return author



def redact(content, priv):
    badwords = []
    with open(priv, 'r') as rd:
        for line in rd.readlines():
            if not line.startswith('#'):
                badwords.append(line.strip())
    for bw in badwords:
        if bw in content:
            def m(bw): return "X" * len(bw)
            content = content.replace(bw, m(bw))
    return content


# #### format message to markdown string

# In[44]:


def parse_message(msg, priv, webpath, msgtype=None, child_ids=None):
    body = get_body(msg)
    if body is None:
       return
    if msgtype == "parent":
        child_str = str(f'''
----
### Child Parameters
\n
mailto_params: {urlencode(dict(reply_to(msg)))}
\n
Children: {child_ids}
        ''')
    content = str(f'''
---
title: {msg.get('Subject')}
author: {get_author(msg)}
subject: {msg.get('subject')}
message-id: {msg['Message-ID']}
date: {get_date(msg)}
\n
## {msg.get('subject')}
\n
{body}
\n
                  ''')
    if msgtype == 'parent':
        content = content + child_str
    content = redact(content, priv)
    return content


# #### Associate function: get Name

# In[9]:


def get_name(message):
    id_raw = message.get('Message-Id')
    mid = id_raw.strip('<').strip('>').strip('+').strip('=')
    name = mid + '.txt'
    return name


# ### Secondary Process: Write Thread

# In[46]:


def write_thread(thread, outdir, priv, webpath):
    if not os.path.isdir(outdir):
        os.mkdir(outdir)
    if thread.get('has_children'):
        parent_message = thread.get('parent')
        unsorted_children = thread.get('children')
        children = sorted(unsorted_children, key=itemgetter('date'), reverse=True)
        child_ids = [i for i['Message-Id'] in children]
        fname = get_name(parent_message)
        fpath = os.path.join(outdir, fname)
        with open(fpath, 'w', encoding='utf-8', errors='xmlcharrefreplace') as of:
            pcontent = parse_message(parent_message, priv, webpath, msgtype='parent', child_ids=child_ids)
            of.write(pcontent)
            of.write('\n')
            of.write('====')
            for child in children:
                child_content = parse_message(child, priv, webpath, msgtype=child, child_ids=None)
                of.write(child_content)
                of.write('\n')
                of.write('----')
            of.close()
    else:
        pmessage = thread.get('parent')
        fname = get_name(pmessage)
        fpath = os.path.join(outdir, fname)
        with open(fpath, 'w', encoding='utf-8', errors='xmlcharrefreplace') as of:
            ocontent = parse_message(pmessage, priv, webpath, msgtype=None, child_ids=None)
            of.write(ocontent)
            of.write('\n')
            of.write('====')
            of.close()


# ### Primary Process: Main

# In[47]:


def main(Options):
    outdir = Options.outdir
    priv = Options.priv
    webpath = Options.webpath
    messages = get_mbox(Options.mbox)
    messages = list(messages)
    parents = []
    print(f'Total number of messages: {len(messages)}')
    for message in messages:
        subj = str(message.get('Subject')).lower()
        repl = message['In-Reply-To']
        mcc = message['Cc']
        if not repl or not mcc:
            if not contains(subj, 're:'):
                parents.append(message)
    for parent in parents:
        for message in messages:
            if parent == message:
                messages.remove(message)
    print(f'Processing {len(messages)} messages with {len(parents)} parents.')
    msg_list = []
    for parent in parents:
        maildict = dict()
        pID = parent.get("Message-Id")
        reply_list = []
        for message in messages:
            if isinstance(message, str):
                message = message.strip()
            if message['In-Reply-To']:
                if pID in message['In-Reply-To']:
                    reply_list.append(message)
        if len(reply_list) >= 1:
            maildict['has_child'] = True
            maildict["parent"] = parent
            maildict["children"] = reply_list
        else:
            maildict['has_child'] = False
            maildict["parent"] = parent
            maildict["children"] = None
        msg_list.append(maildict)
    for thread in msg_list:
        write_thread(thread, outdir, priv, webpath)
    generate_index(msg_list, outdir, webpath)
    print('Done!')


# In[12]:


if __name__ == '__main__':
    #!jupyter nbconvert --to script mailbuffet.ipynb
    main(Options)
