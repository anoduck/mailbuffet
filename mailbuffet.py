#!/usr/bin/env python
# coding: utf-8

# # Mail Buffet
#
# > Extracting Mbox messages to markdown files

# ### Perform imports

# In[2]:


#!/usr/bin/env python3
#! vim:set filetype=python
# -*- coding: utf-8 -*-
# -*- mode: python -*-
# MIT License = 'Copyright (c) 2024 Anoduck'
# This software is released under the MIT License.
# https://anoduck.mit-license.org

# ----------------------------------------------
# This script was inspired by and parts of the code was borrowed from
# an effort to understand how to use the python program formbox written
# by Nguyá»n Gia Phong.
# ---------------------------------------------

from simple_parsing import parse
from dataclasses import dataclass
from operator import itemgetter, contains
from collections import defaultdict
from mailbox import mbox
from email.header import decode_header
from email.utils import parsedate_to_datetime
from urllib.parse import urlencode
import hashlib
from py_markdown_table.markdown_table import markdown_table
import os


# ### Process Args
#
# It appears the ipykernel does not like simple_parsing, which is weird.
#
# Hardcoding args to circumvent.
# In[3]:

@dataclass
class Options:
    """
    A more than simple script to parse the mbox file generated by Google Takeout
    into individual text files with markdown syntax.

    Script also performs redacting based on keyphrase file, a text file containing one
    keyphrase per line saved as a txt file.

    Will generate index file containing markdown_table to provide TOC to files from webpath.

    """
    mbox: str = './exported.mbox'  # Mbox file for extraction
    outdir: str = './results'  # Directory to write files to
    priv: str = './sensitive.txt'  # File containing sensitive key phrases.
    webpath: str = '/Documents/emails'  # Relative Webpath from site root


Options = parse(Options, dest='Options')


# ### Return Mbox object with initializer

# In[4]:


def get_mbox(mbox_file):
    return mbox(mbox_file, create=False)


def write_table(table, filepath):
    mdtbl = markdown_table(table).set_params(row_sep='markdown', quote=False).get_markdown()
    with open(filepath, 'w', encoding='utf-8') as wt:
        title = "## Email Table of Contents"
        wt.write('\n')
        wt.write(title)
        wt.write('\n')
        wt.write('\n')
        wt.write(mdtbl)
        wt.write('\n')
        wt.write('\n')
        wt.write('----')
        wt.write('\n')
        wt.write('Generated by mailbuffet [Mailbuffet](https://github.com/anoduck/mailbuffet)')
        wt.close()
    print('Index written to file')

# ### Generate Index


def generate_index(msg_list, outdir, webpath):
    filename = 'index.md'
    filepath = os.path.join(outdir, filename)
    table = []
    for msg in msg_list:
        if isreply(msg):
            replyto = get_replylink(msg, webpath)
        else:
            replyto = None
        if hasrefs(msg):
            refs = get_reflinks(msg, webpath)
        else:
            refs = None
        flink = get_selflink(msg, webpath)
        parent_subject = get_subject(msg)
        parent_date = get_date(msg)
        tbl_row = {"Subject": parent_subject,
                    "Date": parent_date,
                    "Path": flink,
                    "Reply-to": replyto,
                    "Refs": refs}
        table.append(tbl_row)
    write_table(table, filepath)


# ### Get Message parts

# #### Reply to params (???)

# In[40]:


def reply_to(message):
    """Return mailto parameters for replying to the given email."""
    yield 'In-Reply-To', message['Message-ID']
    yield 'Cc', message.get('Reply-To', message['From'])
    subject = message['Subject']
    if subject is None: return
    if subject.lower().startswith('re:'):
        yield 'Subject', subject
    else:
        yield 'Subject', f'Re: {subject}'


# #### Get Header

# In[41]:


def get_header(msg):
    """Return the decoded email header."""
    header = msg.get('header')
    ret_str = str('### Header: ')
    for string, charset in decode_header(header):
        encoding = 'utf-8' if charset is None else charset
        decoded = string.decode(encoding)
        ret_str += decoded + '\n'
    return ret_str


# #### Get Date

# In[6]:


def get_date(message):
    return parsedate_to_datetime(message['Date']).date()


# #### Get Body

# In[43]:


def get_body(message):
    if message.is_multipart():
        for payload in map(get_body, message.get_payload()):
            if payload is not None: return payload
    elif message.get_content_type() in ('text/markdown', 'text/plain'):
        payload = message.get_payload(decode=True).decode()
        return payload
    else:
        return None


def get_author(message):
    msgfrom = message['From']
    string = [s for s, _ in decode_header(msgfrom)]
    author = ''.join(string).rsplit(maxsplit=1)[0]
    return author



def redact(content, priv):
    badwords = []
    with open(priv, 'r') as rd:
        for line in rd.readlines():
            if not line.startswith('#'):
                badwords.append(line.strip())
    for bw in badwords:
        if bw in content:
            def m(bw): return "X" * len(bw)
            content = content.replace(bw, m(bw))
    return content


def hasrefs(message):
    refs = message.get('References')
    if refs:
        return True
    else:
        return False


# #### format message to markdown string

# In[44]:


def parse_message(msg, priv, webpath):
    body = get_body(msg)
    if body is None:
        return
    if isreply(msg):
        replyto = get_replylink(msg, webpath)
    else:
        replyto = None
    if hasrefs(msg):
        refs = get_reflinks(msg, webpath)
    else:
        refs = None
    content = str(f'''
\n
---
title: {get_subject(msg)}
author: {get_author(msg)}
subject: {get_subject(msg)}
message-id: {getmid(msg)}
date: {get_date(msg)}
---
\n
\n
## {get_subject(msg)}
\n
{get_body(msg)}
\n
\n
### References
\n
{refs}
\n
\n
### Reply-To
\n
{replyto}
\n
                  ''')
    content = redact(content, priv)
    return content


# #### Associate function: get Name

# In[9]:


def sanitize(phrase):
    if not isinstance(phrase, str):
        phrase = str(phrase)
    undesirables = ["<", ">", "+", "=", "_", "-", "'", "'", "\r", "\n", " ", "\r\n "]
    for char in undesirables:
        phrase = phrase.replace(char, '')
    return phrase


def getmid(message):
    mid = message.get('Message-Id')
    mid = sanitize(mid)
    return mid


def get_name(message):
    mid = getmid(message)
    name = mid + '.md'
    return name


def get_replyto(message):
    super = message.get('In-Reply-To')
    target = sanitize(super)
    return target


def get_subject(message):
    subj = message.get('Subject')
    return subj.lower()


def get_ref(message):
    ref_list = []
    refs = message.get('References')
    refs = refs.split(' ')
    for ref in refs:
        ref = sanitize(ref)
        if ref != ' ' and ref != '':
            ref_list.append(ref)
    return ref_list


def get_selflink(message, webpath):
    mid = getmid(message)
    link = webpath + '/' + mid
    link = str(f'[{mid}]({link})')
    return link


def get_replylink(message, webpath):
    id = get_replyto(message)
    link = webpath + '/' + id
    link = str(f'[{id}]({link})')
    return link


def get_reflinks(message, webpath):
    ref_list = get_ref(message)
    link_list = []
    for ref in ref_list:
        link = webpath + '/' + ref
        link = str(f'[{ref}]({link})')
        link_list.append(link)
    return link_list


# ### Secondary Process: Write Thread

# In[46]:


def process_msg(msg, outdir, priv, webpath):
    fname = get_name(msg)
    fpath = os.path.join(outdir, fname)
    with open(fpath, 'w', encoding='utf-8', errors='xmlcharrefreplace') as of:
        pcontent = str(parse_message(msg, priv, webpath))
        of.write(pcontent)
        of.close()


def isreply(message):
    conreply = get_replyto(message)
    subject = get_subject(message)
    if conreply:
        return True
    elif contains(subject, 're:'):
        return True
    else:
        return False


# ### Primary Process: Main

# In[47]:


def main(Options):
    outdir = Options.outdir
    if not os.path.isdir(outdir):
        os.mkdir(outdir)
    priv = Options.priv
    webpath = Options.webpath
    messages = get_mbox(Options.mbox)
    messages = list(messages)
    for msg in messages:
        process_msg(msg, outdir, priv, webpath)
    print('Done!')


# In[12]:


if __name__ == '__main__':
    #!jupyter nbconvert --to script mailbuffet.ipynb
    main(Options)
